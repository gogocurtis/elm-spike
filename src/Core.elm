module Core
    exposing
        ( Model
        , update
        , view
        , init
        , subscriptions
        , initModelWithRoute
        )

{-|
-}

import Debug as D
import Msg exposing (Msg(..))
import Layout
import SignIn
import Session
import Firebase.DB
import Customers.Grid
import Customers.DetailList
import Models.Customer
import Html exposing (Html)
import Routing exposing (Route, Route(..))
import Navigation

type alias EmptyModel =
    {}


type alias Model =
    { detailsModel : Customers.DetailList.Model
    , ordersModel : EmptyModel
    , inventoryModel : EmptyModel
    , signInModel : SignIn.Model
    , dbModel : Firebase.DB.Model
    , session : Session.Session
    , customersById : Models.Customer.CustomersById
    }


initModelWithRoute route =
    let
        session =
            initModel.session
    in
        { initModel
            | session =
                { session
                    | route = route
                }
        }


initModel : Model
initModel =
    { detailsModel = Customers.DetailList.initModel
    , ordersModel = EmptyModel
    , inventoryModel = EmptyModel
    , signInModel = SignIn.initModel
    , dbModel = Firebase.DB.initModel
    , session = Session.init
    , customersById = Models.Customer.emptyCustomersById
    }



--
-- Init establishes the basic data structure.
--


init : ( Model, Cmd Msg )
init =
    let
        c =
            D.log "function" "init"
    in
        ( initModel, Cmd.none )



-- Update is a triggered by a Msg which represents
-- a particular side-effect generated by an actor
--


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    let
        a =
            D.log "model" model

        b =
            D.log "msg" msg

        c =
            D.log "update" "update"
    in
        case msg of
            ChangeRoute route ->
                    ( { model
                        | session = Session.setRoute model.session route
                      }
                    , Navigation.newUrl  ("/" ++ Routing.urlFor route)
                    )
            OnLocationChange location ->
                let
                    newRoute =
                        Routing.parseLocation location
                in
                    ( { model
                        | session = Session.setRoute model.session newRoute
                      }
                     , Cmd.none
                    )

            CustomersDetailListPage a ->
                let
                    currentDetailsModel =
                        model.detailsModel

                    next =
                        Customers.DetailList.update a { currentDetailsModel | customersById = model.customersById }

                    detailsModel =
                        Tuple.first next

                    cmd =
                        Cmd.map CustomersDetailListPage <| Tuple.second next
                in
                    -- operations in details model update can modify the customersById copy
                    -- which will need to be propogated back to the core model
                    ( { model
                        | detailsModel = detailsModel
                        , customersById = detailsModel.customersById
                      }
                    , cmd
                    )

            SignInPage msg ->
                let
                    ( ( signInModel, cmd ), externalMsg ) =
                        (SignIn.update msg model.signInModel)

                    newModel =
                        case externalMsg of
                            SignIn.EstablishSession firebaseModel ->
                                { model
                                    | session = Session.fromFirebaseAuth firebaseModel
                                    , signInModel = signInModel
                                }

                            SignIn.NoOp ->
                                { model | signInModel = signInModel }
                in
                    ( newModel, Cmd.map SignInPage cmd )

            EmptyPage msg ->
                ( model, Cmd.none )

            FirebaseDBSubscription msg ->
                updateForFirebaseDb msg model

            FirebaseDBPage msg ->
                updateForFirebaseDb msg model


updateForFirebaseDb : Firebase.DB.Msg -> Model -> ( Model, Cmd Msg )
updateForFirebaseDb msg model =
    let
        next =
            Firebase.DB.update msg model.dbModel

        dbModel =
            Tuple.first (Tuple.first next)

        componentExternalMsg =
            Tuple.second next

        cmd =
            Cmd.map FirebaseDBPage <| Tuple.second (Tuple.first next)
    in
        case componentExternalMsg of
            Firebase.DB.NoOp ->
                ( { model
                    | dbModel = dbModel
                  }
                , cmd
                )

            Firebase.DB.CustomersSet ->
                let
                    a =
                        Debug.log "customersset msg triggered" dbModel

                    detailsModel =
                        model.detailsModel

                    customersById =
                        dbModel.customersById
                in
                    ( { model
                        | customersById = customersById
                        , detailsModel = { detailsModel | customersById = customersById }
                        , dbModel = dbModel
                      }
                    , cmd
                    )


view : Model -> Html Msg
view model =
    Layout.view model


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.batch
        [ Sub.map SignInPage (SignIn.subscriptions model.signInModel)
        , Sub.map FirebaseDBSubscription (Firebase.DB.subscriptions model.dbModel)
        , Sub.map CustomersDetailListPage (Customers.DetailList.subscriptions model.detailsModel)
        ]
